"""MOTD (Message of the Day) notifier for terminal login."""

import os

import aiofiles
import aiofiles.os
import structlog

from ..models import Config, UpdateResult

logger = structlog.get_logger()


class MOTDNotifier:
    """Update MOTD file with available updates."""

    def __init__(self, config: Config) -> None:
        """Initialize MOTD notifier."""
        self.config = config
        self.motd_file = config.motd_file

    async def notify(self, result: UpdateResult) -> None:
        """Update MOTD with update information."""
        if not self.config.notify_motd:
            return

        try:
            if not result.has_updates:
                # Remove MOTD file if no updates
                await self._remove_motd()
            else:
                # Create/update MOTD file
                await self._write_motd(result)
        except Exception as e:
            logger.error("Failed to update MOTD", error=str(e))

    async def _remove_motd(self) -> None:
        """Remove MOTD file if it exists."""
        if self.motd_file.exists():
            try:
                await aiofiles.os.remove(str(self.motd_file))
                logger.debug("Removed MOTD file")
            except Exception:
                # File might not exist or have permission issues
                pass

    async def _write_motd(self, result: UpdateResult) -> None:
        """Write update information to MOTD file."""
        content = self._generate_motd(result)

        # Ensure parent directory exists
        self.motd_file.parent.mkdir(parents=True, exist_ok=True)

        # Write file with execute permissions for update-motd.d
        async with aiofiles.open(self.motd_file, "w") as f:
            await f.write(content)

        # Make executable
        os.chmod(str(self.motd_file), 0o755)

        logger.info("Updated MOTD", package_count=len(result.packages))

    def _generate_motd(self, result: UpdateResult) -> str:
        """Generate MOTD content."""
        lines = [
            "#!/bin/sh",
            "# Generated by distiller-update",
            "",
        ]

        # Color codes for better visibility
        lines.extend(
            [
                'echo ""',
                'echo "\\033[1;33m*** System Update Available ***\\033[0m"',
                f'echo "\\033[0;36m{result.summary}\\033[0m"',
                'echo ""',
            ]
        )

        # Show package list if not too many
        if len(result.packages) <= 10:
            lines.append('echo "Packages to upgrade:"')
            for pkg in result.packages:
                size_str = f" ({pkg.display_size})" if pkg.size > 0 else ""
                lines.append(
                    f'echo "  • {pkg.name}: {pkg.current_version} → {pkg.new_version}{size_str}"'
                )
        else:
            # Just show count for many packages
            total_size = result.total_size
            if total_size > 0:
                size_str = self._format_size(total_size)
                lines.append(f'echo "Total download size: {size_str}"')

        lines.extend(
            [
                'echo ""',
                'echo "Run \\033[1msudo apt upgrade\\033[0m to install updates"',
                'echo ""',
            ]
        )

        return "\n".join(lines)

    def _format_size(self, size: int) -> str:
        """Format size in human-readable format."""
        if size < 1024:
            return f"{size}B"
        elif size < 1024 * 1024:
            return f"{size / 1024:.1f}KB"
        elif size < 1024 * 1024 * 1024:
            return f"{size / (1024 * 1024):.1f}MB"
        else:
            return f"{size / (1024 * 1024 * 1024):.1f}GB"
